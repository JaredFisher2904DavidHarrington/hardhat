---
title: "package"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(hardhat)
```

TODO - Finish me

## High level ideas here

- Introduce a modeling function that you might use in a package

- Demonstrate the constructor

- Demonstrate an implementation function

- Demonstrate the user facing interface

- Show how to call `mold()` in this setup to preprocess data

- And show how the engine gets added to the constructor

- Then create a `predict()` method

- Create a predict impl

- Add in `forge()` to the predict method

## Introduction

The goal of this vignette is to teach you how to use `mold()` and `forge()` in a modeling package. This is the intended use of these functions, even though they can also be called interactively. Creating a new modeling package has two main stages, creating the modeling function, and implementing a predict method. The stages break down like this:

- Modeling function
  
  - Create a constructor
  
  - Create an implementation function
  
  - Create a user facing function with methods for xy, formula, and recipe interfaces
  
- Predict method

  - Create one or more predict implementation function, varying by the `"type"` of prediction to make
  
  - Create a user facing predict method

## What's our model?

We will 

## `mold()` By Example

The intended use of `mold()` is to be called from your top level modeling function (the one that users will call). Suppose that we have such a function, `modeler()`, along with it's core implementation `modeler_impl()`, and a constructor to make a new `"modeler"` object, `new_modeler()`.

```{r}
# Create a new `modeler` object
new_modeler <- function(y_mean) {
  
  if (!is.numeric(y_mean)) {
    stop("`y_mean` must be numeric.")
  }
  
  elements <- list(
    y_mean = y_mean
  )
  
  structure(elements, class = "modeler")
}

# Implementation function
modeler_impl <- function(x, y) {
  
  # core modeling implementation
  
  list(
    y_mean = mean(y)
  )
}


modeler <- function(x, y) {
  res <- modeler_impl(x, y)
  new_modeler(y_mean = res$y_mean)
}
```

You probably expect users to use `modeler()` like this:

```{r}
# X and Y
x <- iris
x$Petal.Width <- NULL
y <- iris$Petal.Width

modeler(x, y)
```

When it comes time to make predictions, the first thing that you should do inside your `predict()` method is pass the user supplied data to `forge()`, along with the `engine` that was attached to the model object. This will preprocess the `new_data` using the same steps specified when the model was being trained.
