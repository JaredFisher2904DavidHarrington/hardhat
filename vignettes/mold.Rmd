---
title: "Molding data for modeling"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Molding data for modeling}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(hardhat)
```

## Introduction

For most modeling functions, data must be accepted from the user in some format where the _outcomes_ and _predictors_ are both specified. The next step is often to validate and preprocess that input in some way to prepare it for the actual modeling implementation function. For example, when a formula method is used (i.e. terms are specified using `outcomes ~ predictors`), R provides some infrastructure for preprocessing the user input through the `model.frame()` and `model.matrix()` functions. 

But the formula method is not the only way to specify modeling terms. There is also an XY method, where `x` and `y` are supplied directly, and, recently, a `recipe` object can be used to preprocess data using a set of sequential steps.

As a developer, you likely won't want to care about the details of how each of these methods work, but (hopefully) still want to provide all three of these interfaces for your shiny new model. `mold()` makes this easy on you, and takes care of the details of preprocessing user input from any of these methods.

## `mold()` By Example

The intended use of `mold()` is to be called from your top level modeling function (the one that users will call). Suppose that we have such a function, `modeler()`, along with it's core implementation `modeler_impl()`, and a constructor to make a new `"modeler"` object, `new_modeler()`.

```{r}
# Create a new `modeler` object
new_modeler <- function(y_mean) {
  
  if (!is.numeric(y_mean)) {
    stop("`y_mean` must be numeric.")
  }
  
  elements <- list(
    y_mean = y_mean
  )
  
  structure(elements, class = "modeler")
}

# Implementation function
modeler_impl <- function(x, y) {
  
  # core modeling implementation
  
  list(
    y_mean = mean(y)
  )
}


modeler <- function(x, y) {
  res <- modeler_impl(x, y)
  new_modeler(y_mean = res$y_mean)
}
```

You probably expect users to use `modeler()` like this:

```{r}
# X and Y
x <- iris
x$Petal.Width <- NULL
y <- iris$Petal.Width

modeler(x, y)
```


To use it with `mold()`, pass through the input

### `mold()`

`mold()` readies input data for ingestion into a modeling function. It is to be called from the interface layer of your modeling package. For instance, if you have a top level function called `linear_regression()` that accepts input from the user, you would call `mold()` inside of `linear_regression()`, before passing on the input to the actual implementation function, which should be separated from the top level interface and might be called `linear_regression_impl()`.

If your modeling function has a formula interface, `mold()` will call `model.frame()` and `model.matrix()` for you, storing important information such as the predictor factor levels and the class of each predictor and outcome column.

```{r}
iris_train <- iris[1:100,]
iris_test <- iris[101:150,]

processed <- mold(log(Sepal.Length) ~ Species + Petal.Width, iris_train)
```

The return value of `mold()` has three things. The `predictors`, the `outcomes`, and a `engine` that varies based on the interface you are using. Notice that the default behavior for `mold()` is to _not_ add an intercept column. This is completely controlled by the `intercept` argument and not by the formula itself.

```{r}
processed$predictors

processed$outcomes
```

The engine stores a number of things that are useful to any model when it is time to make predictions on new data.

```{r}
names(processed$engine)
```

For instance, the original levels and classes of the predictors are stored automatically.

```{r}
processed$engine$info$predictors$levels

processed$engine$info$predictors$classes
```

There is also an interface for the XY method (providing the predictors and outcome directly to `x` and `y`). The preprocessing that occurs here is minimal, but you can add an intercept to `x` with `intercept = TRUE`. 

Notice how even though `y` is a vector, the `outcomes` slot of the return value _always_ holds a tibble. Because `y` is not a data frame / matrix with existing column names, a default name of `".outcome"` is used.

```{r}
x <- iris_train[, c("Species", "Petal.Width")]
y <- iris_train$Sepal.Length

processed_xy <- mold(x, y, default_xy_engine(intercept = TRUE))

processed_xy$predictors

processed_xy$outcomes
```

Finally, there is an interface for `recipes`. It calls `recipes::prep()` on the recipe for you.

```{r}
suppressPackageStartupMessages(library(recipes))

rec <- recipe(Sepal.Length ~ Species + Petal.Width, iris_train) %>%
  step_log(Sepal.Length) %>%
  step_dummy(Species)

processed_rec <- mold(rec, iris_train)

processed_rec$predictors
```
