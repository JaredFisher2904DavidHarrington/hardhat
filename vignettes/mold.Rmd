---
title: "Molding data for modeling"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Molding data for modeling}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(hardhat)
```

### `mold()`

`mold()` readies input data for ingestion into a modeling function. It is to be called from the interface layer of your modeling package. For instance, if you have a top level function called `linear_regression()` that accepts input from the user, you would call `mold()` inside of `linear_regression()`, before passing on the input to the actual implementation function, which should be separated from the top level interface and might be called `linear_regression_impl()`.

If your modeling function has a formula interface, `mold()` will call `model.frame()` and `model.matrix()` for you, storing important information such as the predictor factor levels and the class of each predictor and outcome column.

```{r}
iris_train <- iris[1:100,]
iris_test <- iris[101:150,]

processed <- mold(log(Sepal.Length) ~ Species + Petal.Width, iris_train)
```

The return value of `mold()` has three things. The `predictors`, the `outcomes`, and a `preprocessor` that varies based on the interface you are using. Notice that the default behavior for `mold()` is to _not_ add an intercept column. This is completely controlled by the `intercept` argument and not by the formula itself.

```{r}
processed$predictors

processed$outcomes
```

The preprocessor stores a number of things that are useful to any model when it is time to make predictions on new data.

```{r}
names(processed$preprocessor)
```

For instance, the original levels and classes of the predictors are stored automatically.

```{r}
processed$preprocessor$predictors$levels

processed$preprocessor$predictors$classes
```

There is also an interface for the XY method (providing the predictors and outcome directly to `x` and `y`). The preprocessing that occurs here is minimal, but you can add an intercept to `x` with `intercept = TRUE`. 

Notice how even though `y` is a vector, the `outcomes` slot of the return value _always_ holds a tibble. Because `y` is not a data frame / matrix with existing column names, a default name of `".outcome"` is used.

```{r}
x <- iris_train[, c("Species", "Petal.Width")]
y <- iris_train$Sepal.Length

processed_xy <- mold(x, y, intercept = TRUE)

processed_xy$predictors

processed_xy$outcomes
```

Finally, there is an interface for `recipes`. It calls `recipes::prep()` on the recipe for you.

```{r}
suppressPackageStartupMessages(library(recipes))

rec <- recipe(Sepal.Length ~ Species + Petal.Width, iris_train) %>%
  step_log(Sepal.Length) %>%
  step_dummy(Species)

processed_rec <- mold(rec, iris_train)

processed_rec$predictors
```
