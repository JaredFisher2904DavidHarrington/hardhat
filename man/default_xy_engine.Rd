% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/engine-xy-default.R
\name{default_xy_engine}
\alias{default_xy_engine}
\alias{new_default_xy_engine}
\title{Create a new default XY engine}
\usage{
default_xy_engine(intercept = FALSE)

new_default_xy_engine(mold, forge, intercept = FALSE, info = NULL, ...,
  subclass = character())
}
\arguments{
\item{intercept}{A logical. Should an intercept be included in the
processed data? This information is used by the \code{process} function
in the \code{mold} and \code{forge} function list.}

\item{mold}{A named list with two elements, \code{clean} and \code{process}, see
the \code{\link[=new_engine]{new_engine()}} section, Mold Functions, for details.}

\item{forge}{A named list with two elements, \code{clean} and \code{process}, see
the \code{\link[=new_engine]{new_engine()}} section, Forge Functions, for details.}

\item{info}{Either \code{NULL}, or a named list with 2 elements, \code{predictors}
and \code{outcomes}. \code{info} is generated automatically at \code{\link[=mold]{mold()}} time and
is used to validate \code{new_data} at prediction time. The
information in \code{predictors} is the \code{predictors$info} element from running
\code{engine$mold$process()} and the information is \code{outcomes} is the
corresponding \code{outcomes$info}.}

\item{...}{Name-value pairs for additional elements of engines that
subclass this engine.}

\item{subclass}{A character vector. The subclasses of this engine.}
}
\value{
A preprocessing engine with the class, \code{"default_xy_engine"} that can
be used with \code{\link[=mold]{mold()}} and \code{\link[=forge]{forge()}}.
}
\description{
This is the constructor for a default XY preprocessing engine. This
is the engine used by default from \code{mold()} if \code{x} and \code{y} are provided
separately (i.e. the XY interface is used). To learn about what the
default mold and forge functionality are, see the Mold and Forge
sections below.
}
\details{
As documented in \code{\link[=standardize]{standardize()}}, if \code{y} is a \emph{vector}, then the returned
outcomes tibble has 1 column with a standardized name of \code{".outcome"}.

The one special thing about the XY method's forge function is the behavior of
\code{outcomes = TRUE} when a \emph{vector} \code{y} value was provided to the original
call to \code{\link[=mold]{mold()}}. In that case, \code{mold()} converted \code{y} into a tibble, with
a default name of \code{.outcome}. This is the column that \code{forge()} will look
for in \code{new_data} to preprocess. See the examples section for a
demonstration of this.
}
\section{Mold}{


The XY engine's mold function does the following:
\itemize{
\item Converts \code{x} to a tibble.
\item Adds an intercept column to \code{x} if \code{intercept = TRUE}.
\item Runs \code{\link[=standardize]{standardize()}} on \code{y}.
}
}

\section{Forge}{


The XY engine's forge function does the following:
\itemize{
\item Calls \code{\link[=shrink]{shrink()}} to trim \code{new_data} to only the required columns and
coerce \code{new_data} to a tibble.
\item Calls \code{\link[=scream]{scream()}} to perform validation on the structure of the columns
of \code{new_data}.
\item Potentially adds an intercept column onto \code{new_data}, if
\code{intercept = TRUE}.
}
}

\examples{

# In all of the examples below, X and Y are supplied to mold(),
# which means that the default_xy_engine() is being used.

# ---------------------------------------------------------------------------
# Setup

train <- iris[1:100,]
test <- iris[101:150,]

train_x <- train[, "Sepal.Length", drop = FALSE]
train_y <- train[, "Species", drop = FALSE]

test_x <- test[, "Sepal.Length", drop = FALSE]
test_y <- test[, "Species", drop = FALSE]

# ---------------------------------------------------------------------------
# XY Example

# First, call mold() with the training data
processed <- mold(train_x, train_y)

# Then, call forge() with the engine and the test data
# to have it preprocess the test data in the same way
forge(test_x, processed$engine)

# ---------------------------------------------------------------------------
# Intercept

processed <- mold(train_x, train_y, default_xy_engine(intercept = TRUE))

forge(test_x, processed$engine)

# ---------------------------------------------------------------------------
# XY Method and forge(outcomes = TRUE)

# You can request that the new outcome columns are preprocessed as well, but
# they have to be present in `new_data`!

processed <- mold(train_x, train_y)

# Can't do this!
\dontrun{
forge(test_x, processed$engine, outcomes = TRUE)
}

# Need to use the full test set, including `y`
forge(test, processed$engine, outcomes = TRUE)

# With the XY method, if the Y value used in `mold()` is a vector,
# then a column name of `.outcome` is automatically generated.
# This name is what forge() looks for in `new_data`.

# Y is a vector!
y_vec <- train_y$Species

processed_vec <- mold(train_x, y_vec)

# This throws an informative error that tell you
# to include an `".outcome"` column in `new_data`.
\dontrun{
forge(iris, processed_vec$engine, outcomes = TRUE)
}

test2 <- test
test2$.outcome <- test2$Species
test2$Species <- NULL

# This works, and returns a tibble in the $outcomes slot
forge(test2, processed_vec$engine, outcomes = TRUE)

}
