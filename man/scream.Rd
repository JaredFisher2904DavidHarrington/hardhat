% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/scream.R
\name{scream}
\alias{scream}
\title{\if{html}{\Sexpr[stage=render,results=rd]{"\U0001f631"}} Scream.}
\usage{
scream(new_data, engine, outcomes = FALSE)
}
\arguments{
\item{new_data}{A data frame containing the new data to check the structure
of. This should contain the predictors, and potentially the outcomes if
\code{outcomes = TRUE}.}

\item{engine}{A preprocessing \code{engine} returned from a call to \code{\link[=mold]{mold()}}.}

\item{outcomes}{A logical. Should the outcomes be checked as well?}
}
\value{
A tibble containing the required predictors (and potentially the
outcomes) after any required structural modifications have been made.
}
\description{
\code{scream()} performs a number of validation checks on \code{new_data}, and yells
loudly if anything is wrong. \code{scream()} performs the following validation:
\itemize{
\item \code{validate_new_data_classes()} - Checks that the class of each
required predictor in \code{new_data} is the same as the class used
during training.
\item \code{enforce_new_data_novel_levels()} - Checks that all \code{new_data} factor
columns don't have any \emph{new} levels when compared with the original data
used in training. If there are new levels, a warning is issued and
if \code{drop_novel = TRUE} then they are coerced to \code{NA}.
\item \code{enforce_new_data_level_recovery()} -  Checks that all \code{new_data} factor
columns aren't missing any factor levels when compared with the original data
used in training. If there are missing levels, then they are restored
and a warning is issued.
}
}
\details{
\code{scream()} is called by \code{\link[=forge]{forge()}} after \code{\link[=shrink]{shrink()}} but before the
actual processing is done. Generally, you don't need to call \code{scream()}
directly, as \code{forge()} will do it for you.

If \code{outcomes = TRUE}, then the validation steps are performed on the known
outcome columns as well. If \code{\link[=mold]{mold()}} was called with the XY interface,
then no preprocessing was done to \code{y} and \code{outcomes} will have no effect
(if a vector was passed as \code{y} during the fit, \code{scream()} has no
way of knowing what column in \code{new_data} corresponds to the outcome).

If \code{scream()} is used as a standalone function, it is good practice to call
\code{\link[=shrink]{shrink()}} right before it as there are no checks in \code{scream()} that ensure
that all of the required column names actually exist in \code{new_data}. Those
checks exist in \code{shrink()}.
}
\examples{
train <- iris[1:100,]
test <- iris[101:150,]

# mold() is run at model fit time
# and a formula preprocessing engine is recorded
x <- mold(log(Sepal.Width) ~ Species, train)

# Pass that engine to shrink(), along with new_data
# to get a tibble of required predictors back
test_shrunk <- shrink(test, x$engine)

# Now pass that to scream() to perform validation checks
# Silence is key!
scream(test_shrunk, x$engine)

# If `outcomes = TRUE` is used with shrink(),
# it should also be used with scream()
test_outcome <- shrink(test, x$engine, outcomes = TRUE)
scream(test_outcome, x$engine, outcomes = TRUE)

# scream() validates that the classes of `new_data`
# are the same as the ones used in mold(). The below call
# to scream() will fail with an informative error.
test2 <- test
test2$Species <- as.character(test2$Species)

\dontrun{
scream(test2, x$engine)
}

}
