% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/engine-recipe-default.R
\name{default_recipe_engine}
\alias{default_recipe_engine}
\alias{new_default_recipe_engine}
\title{Create a new default recipe engine}
\usage{
default_recipe_engine(intercept = FALSE)

new_default_recipe_engine(mold, forge, intercept = FALSE, info = NULL,
  recipe = NULL, ..., subclass = character())
}
\arguments{
\item{intercept}{A logical. Should an intercept be included in the
processed data? This information is used by the \code{process} function
in the \code{mold} and \code{forge} function list.}

\item{mold}{A named list with two elements, \code{clean} and \code{process}, see
the \code{\link[=new_engine]{new_engine()}} section, Mold Functions, for details.}

\item{forge}{A named list with two elements, \code{clean} and \code{process}, see
the \code{\link[=new_engine]{new_engine()}} section, Forge Functions, for details.}

\item{info}{Either \code{NULL}, or a named list with 2 elements, \code{predictors}
and \code{outcomes}. \code{info} is generated automatically at \code{\link[=mold]{mold()}} time and
is used to validate \code{new_data} at prediction time. The
information in \code{predictors} is the \code{predictors$info} element from running
\code{engine$mold$process()} and the information is \code{outcomes} is the
corresponding \code{outcomes$info}.}

\item{recipe}{Either \code{NULL}, or an unprepped recipe. This argument is set
automatically at \code{\link[=mold]{mold()}} time.}

\item{...}{Name-value pairs for additional elements of engines that
subclass this engine.}

\item{subclass}{A character vector. The subclasses of this engine.}
}
\value{
A preprocessing engine with the class, \code{"default_recipe_engine"} that can
be used with \code{\link[=mold]{mold()}} and \code{\link[=forge]{forge()}}.
}
\description{
This is the constructor for a default recipe preprocessing engine. This
is the engine used by default from \code{mold()} if \code{x} is a recipe. To learn
about what the default mold and forge functionality are, see the
Mold and Forge sections below.
}
\section{Mold}{


The recipe engine's mold function does the following:
\itemize{
\item Calls \code{\link[recipes:prep]{recipes::prep()}} to prep the recipe.
\item Calls \code{\link[recipes:juice]{recipes::juice()}} to extract the outcomes and predictors. These
are returned as tibbles.
\item If \code{intercept = TRUE}, adds an intercept column to the predictors.
}
}

\section{Forge}{


The recipe engine's forge function does the following:
\itemize{
\item Calls \code{\link[=shrink]{shrink()}} to trim \code{new_data} to only the required columns and
coerce \code{new_data} to a tibble.
\item Calls \code{\link[=scream]{scream()}} to perform validation on the structure of the columns
of \code{new_data}.
\item Calls \code{\link[recipes:bake]{recipes::bake()}} on the \code{new_data} using the prepped recipe
used during training.
\item Potentially adds an intercept column onto \code{new_data},
if \code{intercept = TRUE}.
}
}

\examples{

library(recipes)

# ---------------------------------------------------------------------------
# Setup

train <- iris[1:100,]
test <- iris[101:150,]

# ---------------------------------------------------------------------------
# Recipes example

# Create a recipe that logs a predictor
rec <- recipe(Species ~ Sepal.Length + Sepal.Width, train) \%>\%
   step_log(Sepal.Length)

processed <- mold(rec, train)

# Sepal.Length has been logged
processed$predictors

processed$outcomes

# The underlying engine is a prepped recipe
processed$engine$recipe

# Call forge() with the engine and the test data
# to have it preprocess the test data in the same way
forge(test, processed$engine)

# Use `outcomes = TRUE` to also extract the preprocessed outcome!
# This logged the Sepal.Length column of `new_data`
forge(test, processed$engine, outcomes = TRUE)

# ---------------------------------------------------------------------------
# With an intercept

# You can add an intercept with `intercept = TRUE`
processed <- mold(rec, train, default_recipe_engine(intercept = TRUE))

processed$predictors

# But you also could have used a recipe step
rec2 <- step_intercept(rec)

mold(rec2, iris)$predictors

}
