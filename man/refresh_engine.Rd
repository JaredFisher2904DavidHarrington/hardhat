% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/engine.R
\name{refresh_engine}
\alias{refresh_engine}
\title{Refresh a preprocessing engine}
\usage{
refresh_engine(engine)
}
\arguments{
\item{engine}{A preprocessing engine.}
}
\value{
\code{engine} is returned after a call to the corresponding constructor.
}
\description{
\code{refresh_engine()} is a developer facing generic function that is called
at the end of \code{\link[=update_engine]{update_engine()}}. It simply is a wrapper around the
method specific \code{new_*_engine()} function that runs the updated engine
through the constructor again to ensure that all of the elements of the
engine are still valid after the update.
}
\details{
If you implement your own custom \code{engine}, you should export a
\code{refresh_engine()} method that just calls the constructor for your engine
and passes through all of the elements of the engine to the constructor.
}
\examples{

engine <- new_default_xy_engine()

# This should never be done manually, but is essentially
# what `update_engine(engine, intercept = TRUE)` does for you
engine$intercept <- TRUE

# Then update_engine() will call refresh_engine()
# to ensure that the structure is correct
refresh_engine(engine)

# So you can't do something like...
engine_bad <- engine
engine_bad$intercept <- 1

# ...because the constructor will catch it
\dontrun{
refresh_engine(engine_bad)
}

# And update_engine() catches this automatically
\dontrun{
update_engine(engine, intercept = 1)
}

}
