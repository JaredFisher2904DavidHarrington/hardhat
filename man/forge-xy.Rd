% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/forge-xy.R
\name{forge.default_preprocessor}
\alias{forge.default_preprocessor}
\title{Forge - XY Method}
\usage{
\method{forge}{default_preprocessor}(preprocessor, new_data,
  outcomes = FALSE, ...)
}
\arguments{
\item{preprocessor}{A \code{"default_preprocessor"}.}

\item{new_data}{A data frame or matrix to preprocess.}

\item{outcomes}{A logical. Should the outcomes be processed and returned
as well?}

\item{...}{Not currently used.}
}
\value{
A named list with 3 elements:
\itemize{
\item \code{predictors}: A tibble containing the preprocessed
\code{new_data} predictors.
\item \code{outcomes}: If \code{outcomes = TRUE}, a tibble containing the preprocessed
\code{new_data} outcomes. Otherwise, \code{NULL}.
\item \code{offset}: If the \code{preprocessor} was a \code{"terms_preprocessor"}, and offsets
were specified in the formula, this is a tibble containing the preprocessed
offsets. Otherwise, \code{NULL}.
}
}
\description{
For the default preprocessor, \code{forge()} does the following:
\itemize{
\item Calls \code{\link[=shrink]{shrink()}} to trim \code{new_data} to only the required columns and
coerce \code{new_data} to a tibble.
\item Calls \code{\link[=scream]{scream()}} to perform validation on the structure of the columns
of \code{new_data}.
\item Calls on the default preprocessor engine to potentially add an intercept
column onto \code{new_data}, if the corresponding call to \code{\link[=mold]{mold()}} used one.
}
}
\details{
The one special thing about the XY method of \code{forge()} is the behavior of
\code{outcomes = TRUE} when a \emph{vector} \code{y} value was provided to the original
call to \code{\link[=mold]{mold()}} (which generated the preprocessor). In that case, \code{mold()}
converted \code{y} into a tibble, with a default name of \code{.outcome}. This is the
column that \code{forge()} will look for in \code{new_data} to preprocess. See the
examples section for a demonstration of this.
}
\examples{

# ---------------------------------------------------------------------------
# Setup

train <- iris[1:100,]
test <- iris[101:150,]

train_x <- train[, "Sepal.Length", drop = FALSE]
train_y <- train[, "Species", drop = FALSE]

test_x <- test[, "Sepal.Length", drop = FALSE]
test_y <- test[, "Species", drop = FALSE]

# ---------------------------------------------------------------------------
# XY Example

# First, call mold() with the training data
processed <- mold(train_x, train_y)

# Then, call forge() with the preprocessor and the test data
# to have it preprocess the test data in the same way
forge(processed$preprocessor, test_x)

# ---------------------------------------------------------------------------
# Intercept

processed <- mold(train_x, train_y, intercept = TRUE)

forge(processed$preprocessor, test_x)

# ---------------------------------------------------------------------------
# XY Method and forge(outcomes = TRUE)

# You can request that the new outcome columns are preprocessed as well, but
# they have to be present in `new_data`!

processed <- mold(train_x, train_y)

# Can't do this!
# forge(processed$preprocessor, test_x, outcomes = TRUE)

# Need to use the full test set, including `y`
forge(processed$preprocessor, test, outcomes = TRUE)

# With the XY method, if the Y value used in `mold()` is a vector,
# then a column name of `.outcome` is automatically generated.
# This name is what forge() looks for in `new_data`.

# Y is a vector!
y_vec <- train_y$Species

processed_vec <- mold(train_x, y_vec)

# This throws an informative error that tell you
# to include an `".outcome"` column in `new_data`.
\dontrun{
forge(processed_vec$preprocessor, iris, outcomes = TRUE)
}

test2 <- test
test2$.outcome <- test2$Species
test2$Species <- NULL

# This works, and returns a tibble in the $outcomes slot
forge(processed_vec$preprocessor, test2, outcomes = TRUE)

}
