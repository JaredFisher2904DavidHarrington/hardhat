% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mold-formula.R
\name{mold.formula}
\alias{mold.formula}
\title{Mold - Formula Method}
\usage{
\method{mold}{formula}(formula, data, intercept = FALSE,
  indicators = TRUE, ...)
}
\arguments{
\item{formula}{A formula specifying the terms of the model, with the outcomes
on the left-hand side of the formula, and the predictors on the right-hand
side.}

\item{data}{A data frame containing the predictors and the outcomes.}

\item{intercept}{A single logical specifying whether or not to
include an intercept in the molded predictors.}

\item{indicators}{Should factors and interactions be expanded
(In other words, should \code{\link[stats:model.matrix]{stats::model.matrix()}} be run)? If
\code{FALSE}, factor columns are returned without being expanded into dummy
variables and a warning is thrown if any interactions are detected.}

\item{...}{Currently unused.}
}
\value{
A named list containing 4 elements:
\itemize{
\item \code{predictors}: A tibble containing the molded predictors to be used in the
model.
\item \code{outcome}: A tibble containing the molded outcomes to be used in the
model.
\item \code{preprocessor}: A \code{"preprocessor"} object for use when making predictions.
\item \code{offset}: A tibble with a single column named \code{".offset"} if an offset
was specified in the formula method. Otherwise, \code{NULL}.
}
}
\description{
For a formula, \code{mold()} does the following:
\itemize{
\item Predictors
\itemize{
\item The RHS of the \code{formula} is isolated, and converted to its own
1 sided formula: \code{~ RHS}.
\item Runs \code{\link[stats:model.frame]{stats::model.frame()}} on the RHS formula and uses \code{data}.
\item If \code{indicators = TRUE}, it then runs \code{\link[stats:model.matrix]{stats::model.matrix()}} on the
result.
\item If \code{indicators = FALSE}, factors are removed before \code{model.matrix()}
is run, and then added back afterwards. No interactions or inline
functions involving factors are allowed.
\item If any offsets are present from using \code{offset()}, then they are
extracted with \code{\link[=model_offset]{model_offset()}}.
\item If \code{intercept = TRUE}, adds an intercept column.
\item Coerces the result of the above steps to a tibble.
}
\item Outcomes
\itemize{
\item The LHS of the \code{formula} is isolated, and converted to its own
1 sided formula: \code{~ LHS}.
\item Runs \code{\link[stats:model.frame]{stats::model.frame()}} on the LHS formula and uses \code{data}.
\item Coerces the result of the above steps to a tibble.
}
}
}
\details{
While not different from base R, the behavior of expanding factors into
dummy variables when an intercept is \emph{not} present should be documented.
\itemize{
\item When an intercept is present, factors are expanded into \code{K-1} new columns,
where \code{K} is the number of levels in the factor.
\item When an intercept is \emph{not} present, factors are expanded into all \code{K}
columns (one-hot encoding).
}

Offsets can be included in the formula method through the use of the inline
function \code{\link[stats:offset]{stats::offset()}}. These are returned as a tibble with 1 column
named \code{".offset"} in the \code{$outcome} slot of the return value.
}
\section{Differences From Base R}{


There are a number of differences from base R regarding how formulas are
processed by \code{mold()} that require some explanation.

Multivariate outcomes can be specified on the LHS using syntax that is
similar to the RHS (i.e. \code{outcome_1 + outcome_2 ~ predictors}).
If any complex calculations are done on the LHS and they return matrices
(like \code{\link[stats:poly]{stats::poly()}}), then those matrices are flattened into multiple
columns of the tibble after the call to \code{model.frame()}. While this is
possible, it is not recommended, and if a large amount of preprocessing is
required on the outcomes you are better off using a \code{\link[recipes:recipe]{recipes::recipe()}}.

Global variables are \emph{not} allowed in the formula. An error will be thrown
if they are included. All terms in the formula should come from \code{data}.

By default, intercepts are \emph{not} included in the predictor output from the
formula. To include an intercept, set \code{intercept = TRUE}. Having an intercept
argument is consistent with the other \code{mold()} methods. More importantly,
there are often modeling packages where an intercept is either always or
never allowed (for example, the \code{earth} package), and they do some fancy
footwork to keep the user from providing or removing an intercept.
This interface standardizes all of that flexibility in one place.
}

\examples{
# ---------------------------------------------------------------------------
# Formula example

processed <- mold(Sepal.Width ~ Species, iris, intercept = TRUE)

processed$predictors

processed$outcomes

# ---------------------------------------------------------------------------
# Factors without an intercept

# No intercept is added
processed <- mold(Sepal.Width ~ Species, iris)

# So factor columns are completely expanded
# into all `K` columns (the number of levels)
processed$predictors

# ---------------------------------------------------------------------------
# Global variables

y <- rep(1, times = nrow(iris))

# In base R, global variables are allowed in a model formula
frame <- model.frame(Species ~ y + Sepal.Length, iris)
head(frame)

# mold() does not allow them, and throws an error
tryCatch(
  expr = mold(Species ~ y + Sepal.Length, iris),
  error = function(e) print(e$message)
)

# ---------------------------------------------------------------------------
# Dummy variables and interactions

# By default, factor columns are expanded
# and interactions are created, both by
# calling model.matrix(). Some models (like
# tree based models) can take factors directly
# but still might want to use the formula method.
# In those cases, set `indicators = FALSE` to not
# run model.matrix() on factor columns. Interactions
# are still allowed and run on numeric columns.

processed <- mold(
  ~ Species + Sepal.Width:Sepal.Length,
  iris,
  indicators = FALSE
)

processed$predictors

# An informative error is thrown when `indicators = FALSE` and
# factors are present in interaction terms or in inline functions
\dontrun{
mold(Sepal.Width ~ Sepal.Length:Species, iris, indicators = FALSE)
mold(Sepal.Width ~ paste0(Species), iris, indicators = FALSE)
}

# ---------------------------------------------------------------------------
# Multivariate outcomes

# Multivariate formulas can be specified easily
processed <- mold(Sepal.Width + log(Sepal.Length) ~ Species, iris)
processed$outcomes

# Inline functions on the LHS are run, but any matrix
# output is flattened (like what happens in `model.matrix()`)
# (essentially this means you don't wind up with columns
# in the tibble that are matrices)
processed <- mold(poly(Sepal.Length, degree = 2) ~ Species, iris)
processed$outcomes

# TRUE
ncol(processed$outcomes) == 2

# ---------------------------------------------------------------------------
# Offsets

# Offsets are handled specially in base R, so they deserve special
# treatment here as well. You can add offsets using the inline function
# offset()
processed <- mold(Sepal.Width ~ offset(Sepal.Length) + Species, iris)

processed$offset

# Multiple offsets can be included, and they get added together
processed <- mold(
  Sepal.Width ~ offset(Sepal.Length) + offset(Petal.Width),
  iris
)

identical(
  processed$offset$.offset,
  iris$Sepal.Length + iris$Petal.Width
)

}
